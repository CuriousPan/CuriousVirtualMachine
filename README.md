# CuriousVirtualMachine
This is a simple stack-based virtual machine implemented from scratch.
<br>
A simple stack-based virtual machine supporting serveral instructions with its assembly.
Compile the code using `make` or `make debug` to see the logs of called instructions in the console. And `./main` to run.
<br>
Here's a list of possible instructions:

`PSH_I`            PUSHES AN ELEMENT ON THE STACK. THE ELEMENT HAS TO BE PROVIDED AS THE FIRST OPERAND<br>
`POP_I`            POPS A NUMBER FROM THE STACK<br>
`ADD_I`            POPS TWO TOP NUMBERS FROM THE STACK, ADDS THEM AND PUSHES THE RESULT ON THE STACK<br>
`SUB_I`            POPS TWO TOP NUMBERS FROM THE STACK, SUBSTRACTS FIRST FROM THE SECOND AND PUSHES THE RESULT ON THE STACK<br>
`PRT_LST_I`        PRINT A TOP-STACK VALUE<br>
`HLT_I`            END THE PROGRAM BY SETTING THE RUNNING FLAG TO FALSE<br>
`CMP_LT_I`         POPS 2 TOP ELEMENTS FROM THE STACK, COMPARES THEM AND PUSHES 1 ON THE STACK IF LEFT NUMBER IS SMALLER THAN RIGHT NUMBER, OTHERWISE 0<br>
`CMP_GT_I`         POPS 2 TOP ELEMENTS FROM THE STACK, COMPARES THEM AND PUSHES 1 ON THE STACK IF LEFT NUMBER IS GREATER THAN RIGHT NUMBER, OTHERWISE 0<br>
`CMP_LET_I`        POPS 2 TOP ELEMENTS FROM THE STACK, COMPARES THEM AND PUSHES 1 ON THE STACK IF LEFT NUMBER IS SMALLER OR EQUALS THAN RIGHT NUMBER, OTHERWISE 0<br>
`CMP_GET_I`        POPS 2 TOP ELEMENTS FROM THE STACK, COMPARES THEM AND PUSHES 1 ON THE STACK IF LEFT NUMBER IS GREATER OR EQUALS THAN RIGHT NUMBER, OTHERWISE 0<br>
`CMP_EQ_I`         POPS 2 TOP ELEMENTS FROM THE STACK, COMPARES THEM AND PUSHES 1 ON THE STACK IF LEFT NUMBER IS EQUAL TO THE RIGHT NUMBER, OTHERWISE 0<br>
`CMP_NEQ_I`        POPS 2 TOP ELEMENTS FROM THE STACK, COMPARES THEM AND PUSHES 1 ON THE STACK IF LEFT NUMBER IS NOT EQUAL TO THE RIGHT NUMBER, OTHERWISE 0<br>
`LD_VAL_I`         LOADS A VALUE FROM A PROVIDED ADDRESS TO THE TOP OF THE STACK. ADDRESS HAS TO BE PROVIDED AS THE FIRST OPERAND<br>
`STR_VAL_I`        POPS A TOP ELEMENT FROM THE STACK AND LOADS TO THE PROVIDED ADDRESS ADDRESS HAS TO BE PROVIDED AS THE FIRST OPERAND<br>
`JMP_BY_IF_ZERO_I` JUMPS BY THE PROVIDED NUMBER OF INSTRUCTIONS, IF ZERO IS ON THE TOP OF THE STACK AND POPS THAT ZERO. NUMBER OF INSTRUCTIONS TO JUMP HAS TO BE PROVIDED AS THE FIRST OPERAND<br>
`JMP_BY_IF_ONE_I`  JUMPS BY THE PROVIDED NUMBER OF INSTRUCTIONS, IF ONE IS ON THE TOP OF THE STACK AND POPS THAT ZERO. NUMBER OF INSTRUCTIONS TO JUMP HAS TO BE PROVIDED AS THE FIRST OPERAND<br>
`JMP_BY_I`         JUMPS BY THE PROVIDED NUMBER OF INSTRUCTIONS. NUMBER OF INSTRUCTIONS TO JUMP HAS TO BE PROVIDED AS THE FIRST OPERAND<br>
`DBG_PRT_I`        PRINT A DEBUG MSG INSTR<br>
`NUM_INSTRUCTIONS` NUMBER OF POSSIBLE INSTRUCTIONS<br>

<br>
An example of code is present in the `main.cpp` file.
